#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : require
// #extension GL_EXT_debug_printf : enable

#include "Loader/VertexDataLoader.glsl"
#include "Loader/MainCameraDataLoader.glsl"
#include "SSBO/StandardSSBO.glsl"

layout(local_size_x = 64) in;
layout(triangles, max_vertices = 64, max_primitives = 124) out;

struct SharedData
{
    uint meshIndex; //todo.Meshlet化
};
taskPayloadSharedEXT SharedData sharedData;

layout(location = 0) out VertexOutput {
	vec4 color;
} vertexOutput[];

void main()
{
    VertexDataMetaData meta = VertexDataLoader_GetVertexDataMetaData(sharedData.meshIndex);
    // debugPrintfEXT("mesh index: %d", sharedData.meshIndex);

    // 出力する頂点数・プリミティブ数を指定
    if (gl_LocalInvocationIndex == 0) {
        SetMeshOutputsEXT(meta.vertexCount, meta.primitiveCount);
    }
    barrier();

    MainCameraData cameraData = MainCameraDataLoader_GetMainCameraData();
    StandardSSBO standardSSBO = StandardSSBO_LoadStandardSSBO(sharedData.meshIndex);

    uint stride = gl_WorkGroupSize.x;
    uint idx = gl_LocalInvocationIndex;

    // 頂点処理：スレッドで分割し、forループで複数頂点を担当
    for (uint i = idx; i < meta.vertexCount; i += stride) 
    {
        VertexData v = VertexDataLoader_GetVertexData(sharedData.meshIndex, i);
        vec4 worldPos = standardSSBO.model * v.position;
        gl_MeshVerticesEXT[i].gl_Position = cameraData.projection * cameraData.view * worldPos;
        vertexOutput[i].color = v.color;

        // debugPrintfEXT("MeshIndex: %d vertex index: %d\n x: %f y: %f z: %f", sharedData.meshIndex, i, v.position.x, v.position.y, v.position.z);
    }

    // プリミティブ処理：同様に分割＋ループで処理
    for (uint i = idx; i < meta.primitiveCount; i += stride) 
    {
        uvec3 index = VertexDataLoader_GetIndexData(sharedData.meshIndex, i);
        gl_PrimitiveTriangleIndicesEXT[i] = index;
        // debugPrintfEXT("MeshIndex: %d index index: %d\n x: %d y: %d z: %d", sharedData.meshIndex, i, index.x, index.y, index.z);
    }
}
