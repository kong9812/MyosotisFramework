#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

#include "Culling/BackfaceCulling.glsl"
#include "Loader/RawDataLoader.glsl"
#include "Loader/VertexDataLoader.glsl"
#include "Loader/MainCameraDataLoader.glsl"

layout(local_size_x = 64) in;
layout(triangles, max_vertices = 64, max_primitives = 124) out;

struct TaskShaderToMeshShaderData
{
    uint _using;
    uint objectIndex;
    uint meshIndex; //todo.Meshlet化
    uint meshletIndex;
};
layout (std430, set = 1, binding = 5) buffer TaskShaderToMeshShaderDataBuffer {
    TaskShaderToMeshShaderData taskShaderToMeshShaderDatas[];
};

layout(location = 0) out VertexOutput {
	vec4 color;
} vertexOutput[];

struct Payload {
    uint StandardSSBOIndex;
    uint MeshletIndex[2000];
};
// max: 16kb
taskPayloadSharedEXT Payload payload;

vec4 randomColor(float seed)
{
    // ハッシュ関数的に疑似乱数を生成
    float r = fract(sin(seed * 12.9898) * 43758.5453);
    float g = fract(sin((seed + 1.0) * 78.233) * 43758.5453);
    float b = fract(sin((seed + 2.0) * 39.425) * 43758.5453);
    return vec4(r, g, b, 1.0);
}

shared uint primitiveCount;

void main()
{
    // データ関連
    uint standardSSBOIndex = payload.StandardSSBOIndex;
    uint meshletIndex = payload.MeshletIndex[gl_WorkGroupID.x];
    StandardSSBO standardSSBO = RawDataLoader_LoadStandardSSBO(standardSSBOIndex);
    uint meshDataIndex = standardSSBO.meshDataIndex;

    // // よく使うデバッグログ
    // debugPrintfEXT("mesh shader gl_WorkGroupID.x: %d threadID: %d StandardSSBOIndex: %d MeshDataIndex: %d MeshletIndex: %d",
    //  gl_WorkGroupID.x, gl_LocalInvocationID.x, payload.StandardSSBOIndex, meshDataIndex, payload.MeshletIndex[gl_WorkGroupID.x]);

    MainCameraData cameraData = MainCameraDataLoader_GetMainCameraData();
    MeshData meshData = VertexDataLoader_GetMeshData(meshDataIndex);
    MeshletMetaData meshletMetaData = VertexDataLoader_GetMeshletMetaData(meshDataIndex, meshletIndex);

    // 0番目のスレッドのみ実行する内容
    if (gl_LocalInvocationIndex == 0) 
    {
        // プリミティブサイズ
        primitiveCount = 0;
    }
    barrier();

    uint stride = gl_WorkGroupSize.x;
    uint idx = gl_LocalInvocationIndex;

    // 頂点処理：スレッドで分割し、forループで複数頂点を担当
    for (uint i = idx; i < meshletMetaData.vertexCount; i += stride) 
    {
        uint index = VertexDataLoader_GetUniqueIndexData(meshDataIndex, meshletIndex, i);
        VertexData v = VertexDataLoader_GetVertexData(meshDataIndex, meshletIndex, index);
        vec4 worldPos = standardSSBO.model * v.position;
        gl_MeshVerticesEXT[i].gl_Position = cameraData.projection * cameraData.view * worldPos;
        vertexOutput[i].color = randomColor(meshletIndex);
    }

    // プリミティブ処理：同様に分割＋ループで処理
    for (uint i = idx; i < meshletMetaData.primitiveCount; i += stride) 
    {
        // プリミティブインデックス
        uvec3 index = VertexDataLoader_GetPrimitivesData(meshDataIndex, meshletIndex, i);

        // 頂点インデックス -> VertexData -> VertexPosition -> バックフェース判定
        vec4 pos[3];
        uint uniqueIndexIndex = VertexDataLoader_GetUniqueIndexData(meshDataIndex, meshletIndex, index.x);
        VertexData v = VertexDataLoader_GetVertexData(meshDataIndex, meshletIndex, uniqueIndexIndex);
        pos[0] = standardSSBO.model * v.position;
        uniqueIndexIndex = VertexDataLoader_GetUniqueIndexData(meshDataIndex, meshletIndex, index.y);
        v = VertexDataLoader_GetVertexData(meshDataIndex, meshletIndex, uniqueIndexIndex);
        pos[1] = standardSSBO.model * v.position;
        uniqueIndexIndex = VertexDataLoader_GetUniqueIndexData(meshDataIndex, meshletIndex, index.z);
        v = VertexDataLoader_GetVertexData(meshDataIndex, meshletIndex, uniqueIndexIndex);
        pos[2] = standardSSBO.model * v.position;

        // バックフェースカリング
        if (BackfaceCulling_IsVisible(pos[0].xyz, pos[1].xyz, pos[2].xyz))
        {
            uint outIndex = atomicAdd(primitiveCount, 1);
            gl_PrimitiveTriangleIndicesEXT[outIndex] = index;
        }
    }

    // 0番目のスレッドのみ実行する内容
    if (gl_LocalInvocationIndex == 0) 
    {
        // 出力する頂点数・プリミティブ数を指定
        SetMeshOutputsEXT(meshletMetaData.vertexCount, primitiveCount);
    }
}
