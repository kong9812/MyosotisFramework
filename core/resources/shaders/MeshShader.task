#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

#include "Loader/RawDataLoader.glsl"
#include "Loader/VertexDataLoader.glsl"
#include "Loader/Sampler2DLoader.glsl"
#include "Culling/FrustumCulling.glsl"

layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform PushConstant {
    uint hiZSamplerID;
    uint checkFalseNegativeMesh;
};

const uint MeshletMax = 2000;

struct Payload {
    uint StandardSSBOIndex;
    uint MeshletIndex[MeshletMax];
};
// max: 16kb
taskPayloadSharedEXT Payload payload;

// 最終的にMeshlet見えてる枚数
shared uint localMeshletCount;

shared bool sFrustumVisible;
shared bool sOccVisible;

// memo
// 複雑になってきたので、いったんわかりやすさを優先にするため、
// 処理を再分割し無駄のifも多く含むが、いったん良しとする。
// memo
shared vec2 sMinUV;
shared vec2 sMaxUV;
shared float sMinDepth;
shared uint sPrevDepthMax_u;
shared float sPrevDepthMax;
shared bool sVisible;

// 8頂点の一時置き場（共有配列）
shared vec2  sLocalUV[8];
shared float sLocalDepth[8];

void main()
{
    // forループの際にスレッドそれぞれのインクリメント値
    const uint stride = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;

    // CPPから指定スレッドIDを使ってメッシュオブジェクト処理の分割を行う
    uint standardSSBOIndex = gl_WorkGroupID.x;

    // 初期(フェーズ1)のmipマップ指定
    int mipLevel = 4;

    // フェーズ判定
    if (checkFalseNegativeMesh == 1)
    {
        // このスレッドIDオブジェクトはフェーズ1で処理できた
        if (standardSSBOIndex >= VertexDataLoader_GetFalseNegativeSize()) return;

        // オブジェクトIndexを取り出す
        standardSSBOIndex = VertexDataLoader_GetFalseNegativeStandardSSBOIndex(gl_WorkGroupID.x);

        // 詳細チェックを行うためのmipmap (primary depthは mip0 しかない)
        mipLevel = 0;
    }

    // 初期化
    if (gl_LocalInvocationIndex == 0) 
    {
        sFrustumVisible = false;
        sOccVisible = false;
    }
    memoryBarrierShared();
    barrier();
    
    // 前フレームで使ってた値のリセット (フェーズ1しかいらないけど、まぁいいか？)
    VertexDataLoader_ResetFalseNegativeSize();

    // データの整合性を保つためにバリアを張っておく
    barrier();

    // オブジェクトデータ取得
    StandardSSBO standardSSBO = RawDataLoader_LoadStandardSSBO(standardSSBOIndex);
    MeshData meshData = VertexDataLoader_GetMeshData(standardSSBO.meshDataIndex);

    // OBBデータの作成
    OBBData obbData = FrustumCulling_CreateOBBData(meshData.AABBMin.xyz, meshData.AABBMax.xyz, standardSSBO.position.xyz, standardSSBO.rotation.xyz, standardSSBO.scale.xyz);

    // 1. フラスタムカリング
    if (gl_LocalInvocationIndex == 0) 
    {
        sFrustumVisible = FrustumCulling_IsVisible(obbData);
    }
    barrier();
    if (!sFrustumVisible) return;

    // 2. 2PhaseOccCulling    
    // カメラデータ取得
    MainCameraData cameraData = MainCameraDataLoader_GetMainCameraData();

    // 初期化 (0番目のみ実行する)
    if (gl_LocalInvocationIndex == 0)
    {
        sMinUV = vec2( 1.0);    // [スクリーンスペース] 矩形の範囲 min
        sMaxUV = vec2(-1.0);    // [スクリーンスペース] 矩形の範囲 max
        sMinDepth = 1.0;        // 矩形の最小深度
        sPrevDepthMax_u = 0;    // depthBufferの最大深度
        sVisible = false;
    }
    barrier();

    vec3 aabbMin = meshData.AABBMin.xyz;
    vec3 aabbMax = meshData.AABBMax.xyz;

    // AABBの8頂点をスクリーン座標に投影し、矩形を作る (最初の8スレッドのみ計算)
    // ローカルバッファ
    if (gl_LocalInvocationIndex < 8)
    {    
        vec3 corners[8] = vec3[](
            vec3(aabbMin.x, aabbMin.y, aabbMin.z),   // - - -
            vec3(aabbMax.x, aabbMax.y, aabbMax.z),   // + + +
            vec3(aabbMax.x, aabbMin.y, aabbMin.z),   // + - -
            vec3(aabbMin.x, aabbMax.y, aabbMin.z),   // - + -
            vec3(aabbMin.x, aabbMin.y, aabbMax.z),   // - - +
            vec3(aabbMax.x, aabbMax.y, aabbMin.z),   // + + -
            vec3(aabbMin.x, aabbMax.y, aabbMax.z),   // - + +
            vec3(aabbMax.x, aabbMin.y, aabbMax.z)    // + - +
        );
        vec4 clip = cameraData.projection * cameraData.view * (standardSSBO.model * vec4(corners[gl_LocalInvocationIndex], 1.0));
        vec3 ndc = clip.xyz / clip.w;   // クリップ座標 -> NDC [-1~1]
        vec2 uv = ndc.xy * 0.5 + 0.5;   // NDC座標 -> UV [0~1]
        sLocalUV[gl_LocalInvocationIndex] = uv;        
        sLocalDepth[gl_LocalInvocationIndex] = ndc.z;
        // debugPrintfEXT("sLocalDepth[%d]: %f", gl_LocalInvocationIndex, sLocalDepth[gl_LocalInvocationIndex]);
    }
    barrier();

    // atomicMinとatomicMaxを使わずthread==0で処理してもらう
    if (gl_LocalInvocationIndex == 0)
    {
        sMinUV = sLocalUV[0];
        sMaxUV = sLocalUV[0];
        sMinDepth = sLocalDepth[0];
        for (uint i = 1; i < 8; i++)
        {
            sMinUV.x = min(sMinUV.x, sLocalUV[i].x);
            sMinUV.y = min(sMinUV.y, sLocalUV[i].y);
            sMaxUV.x = max(sMaxUV.x, sLocalUV[i].x);
            sMaxUV.y = max(sMaxUV.y, sLocalUV[i].y);
            sMinDepth = min(sMinDepth, sLocalDepth[i]);
        }
        sMinUV = clamp(sMinUV, vec2(0.0), vec2(1.0));
        sMaxUV = clamp(sMaxUV, vec2(0.0), vec2(1.0));
    }
    barrier();

    // ここからは一番重く、スレッド分割が期待できるところ
    // デップステクスチャのサイズ (mip指定)
    ivec2 mipTexSize = Sampler2DLoader_GetTextureSize(hiZSamplerID, mipLevel);

    // depth画像のテクセル位置に変換
    ivec2 minTexel = ivec2(sMinUV * vec2(mipTexSize));
    ivec2 maxTexel = ivec2(sMaxUV * vec2(mipTexSize));

    // 制限
    minTexel = max(minTexel, ivec2(0));
    maxTexel = min(maxTexel, mipTexSize - ivec2(1));
    barrier();

    // AABB矩形が0なら見える
    if (maxTexel.x <= minTexel.x || maxTexel.y <= minTexel.y) 
    {
        if (gl_LocalInvocationIndex == 0) {
            sVisible = true;
        }
        barrier();
    }
    barrier();

    // テクセル数
    uint width  = uint(maxTexel.x - minTexel.x + 1);
    uint height = uint(maxTexel.y - minTexel.y + 1);
    uint totalSize = width * height;

    // ローカルスレッドの最大
    float localMax = -1.0;

    // いよいよfor
    for (uint i = gl_LocalInvocationIndex; i < totalSize; i += stride)
    {
        uint ix = i % width;  // x (eg: 10*20の画像なら 10~19の時 0~9が出てくる、x軸の位置)
        uint iy = i / width;  // y (eg: 10*20の画像なら 12の時 1出てくる、y軸の位置)
        ivec2 tc = ivec2(int(ix) + minTexel.x, int(iy) + minTexel.y);   // depthにあるAABBの位置の左上位置から計算
        float d = texelFetch(Sampler2D[hiZSamplerID], tc, mipLevel).r;
        localMax = max(localMax, d);
    }

    uint localU = (localMax < 0.0) ? 0 : floatBitsToUint(localMax);
    atomicMax(sPrevDepthMax_u, localU);
    barrier();

    // 判定
    if (gl_LocalInvocationIndex == 0)
    {
        sPrevDepthMax = uintBitsToFloat(sPrevDepthMax_u);
        sVisible = (sMinDepth <= sPrevDepthMax);        
    }
    barrier();

    // フェーズ2のチャンスを与える
    if (!sVisible)
    {
        if (gl_LocalInvocationIndex == 0 && checkFalseNegativeMesh == 0)
        {
            uint falseNegativeIndex = VertexDataLoader_IncrementFalseNegativeStandardSSBOIndex();
            falseNegativeStandardSSBOIndex[falseNegativeIndex] = standardSSBOIndex;
        }
        return;
    }

    {// 3. それぞれのMeshlet判定
        // 初期化 (0番目のみ実行する)
        if (gl_LocalInvocationIndex == 0)
        {
            localMeshletCount = 0;
        }
        barrier();

        // 全部の枚数をforで回す (スレッド分割)
        for (uint i = gl_LocalInvocationIndex; i < meshData.meshletMetaDataCount; i += stride)
        {
            // Meshletデータ取得
            MeshletMetaData meshletMetaData = VertexDataLoader_GetMeshletMetaData(standardSSBO.meshDataIndex, i);
            
            // OBBデータの作成
            obbData = FrustumCulling_CreateOBBData(meshletMetaData.AABBMin.xyz, meshletMetaData.AABBMax.xyz, standardSSBO.position.xyz, standardSSBO.rotation.xyz, standardSSBO.scale.xyz);
            
            // 可視判定
            bool meshletFrustumCulling = FrustumCulling_IsVisible(obbData);
            if (meshletFrustumCulling)
            {
                uint payloadIndex = atomicAdd(localMeshletCount, 1);
                if (payloadIndex < MeshletMax)  // 制限を超えないように
                {
                    payload.MeshletIndex[payloadIndex] = i;    // payloadに見えるMeshletのIDを保管
                }
            }
        }
    }

    // データ整合性を保つ
    barrier();

    // 3.で見える判定出たMeshletが1枚でもあったらMeshへGO (0番目のみ実行する)
    if (localMeshletCount > 0 && gl_LocalInvocationIndex == 0)
    {
        payload.StandardSSBOIndex = standardSSBOIndex;  // このスレッドで処理したオブジェクトIDをMeshシェーダに教える
        EmitMeshTasksEXT(localMeshletCount, 1, 1);      // todo. 全部使ってもいいかなぁ(さらに分散？)… (Meshシェーダ起こす負荷が高くなければ…)
    }
}