#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

#include "Descriptors/ObjectInfo.glsl"
#include "Descriptors/VBDispatchInfo.glsl"
#include "Descriptors/CameraInfo.glsl"
#include "Descriptors/MeshInfo.glsl"
#include "Descriptors/MeshletInfo.glsl"
#include "Descriptors/FalseNegativeVBDispatchInfoIndex.glsl"

#include "Culling/FrustumCulling.glsl"
#include "Culling/2PhaseOcclusionCulling.glsl"

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstant {
    float hiZMipLevelMax;
    uint hiZSamplerID;
    uint pcVBDispatchInfoCount;
    uint phase;
};

struct Payload {
    uint vbDispatchInfoIndex[128];
    uint renderCount;
};
taskPayloadSharedEXT Payload payload;

shared uint sRenderCount;

void main()
{
    if (gl_LocalInvocationIndex == 0) 
    {
        sRenderCount = 0;
    }
     // phase 1
    if ((gl_GlobalInvocationID.x == 0) && (phase == 1))
    {
        FalseNegativeVBDispatchInfoIndex_ResetCount();
    }
    barrier();

    uint VBDispatchInfoIndex = gl_GlobalInvocationID.x;
    uint vbDispatchInfoCount = pcVBDispatchInfoCount;

    // phase 1
    if (phase == 1)
    {
        FalseNegativeVBDispatchInfoIndex_Reset(VBDispatchInfoIndex);
    }
    else
    {
        // phase 2
        vbDispatchInfoCount = FalseNegativeVBDispatchInfoIndex_GetCount();
        VBDispatchInfoIndex = FalseNegativeVBDispatchInfoIndex_GetIndex(gl_GlobalInvocationID.x);
    }

    if (gl_GlobalInvocationID.x < vbDispatchInfoCount)
    {
        debugPrintfEXT("InVBDispatchInfoIndex: %d [%d]", VBDispatchInfoIndex, gl_GlobalInvocationID.x);

        // VBDispatchInfo
        VBDispatchInfo dispactchInfo = VBDispatchInfo_GetVBDispatchInfo(VBDispatchInfoIndex);

        if (VBDispatchInfo_IsForceDraw(dispactchInfo.bitFlags))
        {
            // ObjectInfo
            uint objectID = dispactchInfo.objectID;
            ObjectInfo objectInfo = ObjectInfo_GetObjectInfo(dispactchInfo.objectID);

            // MeshInfo
            uint meshID = dispactchInfo.meshID;
            MeshInfo meshInfo = MeshInfo_GetMeshInfo(meshID);

            // MeshletInfo
            uint meshletID = meshInfo.meshletInfoOffset + dispactchInfo.meshletID;
            MeshletInfo meshletInfo = MeshletInfo_GetMeshletInfo(meshletID);

            // OBBData
            OBBData meshletOBBData = FrustumCulling_CreateOBBData(meshletInfo.AABBMin.xyz, meshletInfo.AABBMax.xyz, objectInfo.transform.pos.xyz, objectInfo.transform.rot.xyz, objectInfo.transform.scale.xyz);

            // CameraInfo (MainCameraData)
            CameraData cameraData = CameraInfo_GetCameraData(CameraInfo_GetMainCameraIndex());

            //=============================================================================================================================================================================
            // 1. フラスタムカリング
            //=============================================================================================================================================================================
            bool frustumVisible = FrustumCulling_IsVisible(cameraData.frustumPlanes, meshletOBBData);
            if (frustumVisible) 
            {                
                bool occCullingVisible = TwoPhaseOcclusionCulling_IsVisible(meshletInfo.AABBMin.xyz, meshletInfo.AABBMax.xyz, objectInfo.model, cameraData.projection, cameraData.view, hiZSamplerID, hiZMipLevelMax);
                if (occCullingVisible)
                {
                    uint appendIndex = atomicAdd(sRenderCount, 1);
                    payload.vbDispatchInfoIndex[appendIndex] = VBDispatchInfoIndex;
                    debugPrintfEXT("VBDispatchInfoIndex: %d", VBDispatchInfoIndex);
                }
                else if (phase == 1)
                {
                    uint appendIndex = atomicAdd(falseNegativeVBDispatchInfoIndexCount, 1);
                    FalseNegativeVBDispatchInfoIndex_SetData(appendIndex, VBDispatchInfoIndex);
                }
            }
        }
        else
        {
            // 強制描画
            uint appendIndex = atomicAdd(sRenderCount, 1);
            payload.vbDispatchInfoIndex[appendIndex] = VBDispatchInfoIndex;
        }
    }
    barrier();
    if (gl_LocalInvocationIndex == 0)
    {
        payload.renderCount = sRenderCount;
    }
    barrier();
    EmitMeshTasksEXT(sRenderCount, 1, 1);
}