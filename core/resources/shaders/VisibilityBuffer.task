#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

#include "Descriptors/ObjectInfo.glsl"
#include "Descriptors/VBDispatchInfo.glsl"
#include "Descriptors/CameraInfo.glsl"
#include "Descriptors/MeshInfo.glsl"
#include "Descriptors/MeshletInfo.glsl"

#include "Loader/Sampler2DLoader.glsl"

#include "Culling/FrustumCulling.glsl"

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstant {
    uint hiZSamplerID;
    uint checkFalseNegativeMesh;
};

struct Payload {
    uint vbDispatchInfoIndex;
};
taskPayloadSharedEXT Payload payload;

// memo
// 複雑になってきたので、いったんわかりやすさを優先にするため、
// 処理を再分割し無駄のifも多く含むが、いったん良しとする。
// memo
shared vec2 sMinUV;
shared vec2 sMaxUV;
shared float sMinDepth;
shared int sPrevDepthMax_u;
shared float sPrevDepthMax;

// 8頂点の一時置き場（共有配列）
shared vec2  sLocalUV[8];
shared float sLocalDepth[8];

// 判定結果
shared bool sOccCullingVisible;
shared bool sFrustumVisible;

void main()
{
    // VBDispatchInfo
    VBDispatchInfo dispactchInfo = VBDispatchInfo_GetVBDispatchInfo(gl_WorkGroupID.x);

    // ObjectInfo
    uint objectID = dispactchInfo.objectID;
    ObjectInfo objectInfo = ObjectInfo_GetObjectInfo(dispactchInfo.objectID);

    // MeshInfo
    uint meshID = dispactchInfo.meshID;
    MeshInfo meshInfo = MeshInfo_GetMeshInfo(meshID);

    // MeshletInfo
    uint meshletID = meshInfo.meshletInfoOffset + dispactchInfo.meshletID;
    MeshletInfo meshletInfo = MeshletInfo_GetMeshletInfo(meshletID);

    // OBBData
    OBBData meshletOBBData = FrustumCulling_CreateOBBData(meshletInfo.AABBMin.xyz, meshletInfo.AABBMax.xyz, objectInfo.transform.pos.xyz, objectInfo.transform.rot.xyz, objectInfo.transform.scale.xyz);

    // CameraInfo (MainCameraData)
    CameraData cameraData = CameraInfo_GetCameraData(CameraInfo_GetMainCameraIndex());

    //=============================================================================================================================================================================
    // 1. フラスタムカリング
    //=============================================================================================================================================================================
    if (gl_LocalInvocationIndex == 0) 
    {
        sFrustumVisible = FrustumCulling_IsVisible(cameraData.frustumPlanes, meshletOBBData);
    }
    barrier();
    if (!sFrustumVisible) return;

    //=============================================================================================================================================================================
    // 2. 2PhaseOccCulling    
    //=============================================================================================================================================================================
    // 初期化 (0番目のみ実行する)
    if (gl_LocalInvocationIndex == 0)
    {
        sMinUV = vec2( 1.0);    // [スクリーンスペース] 矩形の範囲 min
        sMaxUV = vec2(-1.0);    // [スクリーンスペース] 矩形の範囲 max
        sMinDepth = 1.0;        // 矩形の最小深度
        sPrevDepthMax_u = 0;    // depthBufferの最大深度
        sPrevDepthMax = 0.0;
        sOccCullingVisible = false;
    }
    barrier();

    // AABBの8頂点をスクリーン座標に投影し、矩形を作る (最初の8スレッドのみ計算)
    // ローカルバッファ
    if (gl_LocalInvocationIndex < 8)
    {    
        vec3 aabbMin = meshletInfo.AABBMin.xyz;
        vec3 aabbMax = meshletInfo.AABBMax.xyz;

        vec3 corners[8] = vec3[](
            vec3(aabbMin.x, aabbMin.y, aabbMin.z),   // - - -
            vec3(aabbMax.x, aabbMax.y, aabbMax.z),   // + + +
            vec3(aabbMax.x, aabbMin.y, aabbMin.z),   // + - -
            vec3(aabbMin.x, aabbMax.y, aabbMin.z),   // - + -
            vec3(aabbMin.x, aabbMin.y, aabbMax.z),   // - - +
            vec3(aabbMin.x, aabbMax.y, aabbMax.z),   // - + +
            vec3(aabbMax.x, aabbMin.y, aabbMax.z),   // + - +
            vec3(aabbMax.x, aabbMax.y, aabbMin.z)    // + + -
        );
        vec4 clip = cameraData.projection * cameraData.view * (objectInfo.model * vec4(corners[gl_LocalInvocationIndex], 1.0));
        vec3 ndc = clip.xyz / clip.w;   // クリップ座標 -> NDC [-1~1]
        vec2 uv = ndc.xy * 0.5 + 0.5;   // NDC座標 -> UV [0~1]
        sLocalUV[gl_LocalInvocationIndex] = uv;        
        sLocalDepth[gl_LocalInvocationIndex] = ndc.z;
    }
    barrier();

    // atomicMinとatomicMaxを使わずthread==0で処理してもらう
    if (gl_LocalInvocationIndex == 0)
    {
        sMinUV = sLocalUV[0];
        sMaxUV = sLocalUV[0];
        sMinDepth = sLocalDepth[0];
        for (uint i = 1; i < 8; i++)
        {
            sMinUV.x = min(sMinUV.x, sLocalUV[i].x);
            sMinUV.y = min(sMinUV.y, sLocalUV[i].y);
            sMaxUV.x = max(sMaxUV.x, sLocalUV[i].x);
            sMaxUV.y = max(sMaxUV.y, sLocalUV[i].y);
            sMinDepth = min(sMinDepth, sLocalDepth[i]);
        }
        sMinUV = clamp(sMinUV, vec2(0.0), vec2(1.0));
        sMaxUV = clamp(sMaxUV, vec2(0.0), vec2(1.0));
    }
    barrier();

    float localMax = -1.0;

    if (gl_LocalInvocationIndex == 0) 
    {
        float bias = 0.0005;
        ivec2 mip0TextureSize = Sampler2DLoader_GetTextureSize(hiZSamplerID, 0);

        // AABB Size
        float aabbWidth = (sMaxUV.x - sMinUV.x) * float(mip0TextureSize.x);
        float aabbHeight = (sMaxUV.y - sMinUV.y) * float(mip0TextureSize.y);
        float maxDim = max(aabbWidth, aabbHeight);

        float mipLevel = 0.0;
        if (maxDim > 1.0)
        {
            mipLevel = floor(log2(maxDim));
        }
        ivec2 targetMipTextureSize = Sampler2DLoader_GetTextureSize(hiZSamplerID, int(mipLevel));

        ivec2 minTexel = ivec2(sMinUV * targetMipTextureSize);
        ivec2 maxTexel = ivec2(sMaxUV * targetMipTextureSize);
        for (int x = minTexel.x; x <= maxTexel.x; x++)
        {
            for (int y = minTexel.y; y <= maxTexel.y; y++)
            {
                float occluderDepth = Sampler2DLoader_TexelFetch(hiZSamplerID, ivec2(x, y), int(mipLevel)).r;
                if ((occluderDepth + bias) >= sMinDepth)
                {
                    sOccCullingVisible = true;
                    break;
                }
            }
        }
    }
    barrier();

    // フェーズ2のチャンスを与える
    if (!sOccCullingVisible)
    {
        return;
    }
    // データ整合性を保つ
    barrier();

    if (gl_LocalInvocationIndex == 0)
    {
        payload.vbDispatchInfoIndex = gl_WorkGroupID.x;
        EmitMeshTasksEXT(1, 1, 1);
    }
}