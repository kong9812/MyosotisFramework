#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

#include "Descriptors/ObjectInfo.glsl"
#include "Descriptors/VBDispatchInfo.glsl"
#include "Descriptors/CameraInfo.glsl"
#include "Descriptors/MeshInfo.glsl"
#include "Descriptors/MeshletInfo.glsl"

#include "Loader/Sampler2DLoader.glsl"

#include "Culling/FrustumCulling.glsl"

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstant {
    float hiZMipLevelMax;
    uint hiZSamplerID;
    uint vbDispatchInfoCount;
};

struct Payload {
    uint vbDispatchInfoIndex[128];
    uint renderCount;
};
taskPayloadSharedEXT Payload payload;

shared uint sRenderCount;

void main()
{
    if (gl_LocalInvocationIndex == 0) 
    {
        sRenderCount = 0;
    }
    barrier();

    if (gl_GlobalInvocationID.x <= vbDispatchInfoCount)
    {
        // VBDispatchInfo
        VBDispatchInfo dispactchInfo = VBDispatchInfo_GetVBDispatchInfo(gl_GlobalInvocationID.x);

        if (VBDispatchInfo_IsCullingObject(dispactchInfo.bitFlags))
        {
            // ObjectInfo
            uint objectID = dispactchInfo.objectID;
            ObjectInfo objectInfo = ObjectInfo_GetObjectInfo(dispactchInfo.objectID);

            // MeshInfo
            uint meshID = dispactchInfo.meshID;
            MeshInfo meshInfo = MeshInfo_GetMeshInfo(meshID);

            // MeshletInfo
            uint meshletID = meshInfo.meshletInfoOffset + dispactchInfo.meshletID;
            MeshletInfo meshletInfo = MeshletInfo_GetMeshletInfo(meshletID);

            // OBBData
            OBBData meshletOBBData = FrustumCulling_CreateOBBData(meshletInfo.AABBMin.xyz, meshletInfo.AABBMax.xyz, objectInfo.transform.pos.xyz, objectInfo.transform.rot.xyz, objectInfo.transform.scale.xyz);

            // CameraInfo (MainCameraData)
            CameraData cameraData = CameraInfo_GetCameraData(CameraInfo_GetMainCameraIndex());

            //=============================================================================================================================================================================
            // 1. フラスタムカリング
            //=============================================================================================================================================================================
            bool frustumVisible = FrustumCulling_IsVisible(cameraData.frustumPlanes, meshletOBBData);
            if (frustumVisible) 
            {                
                //=============================================================================================================================================================================
                // 2. 2PhaseOccCulling    
                //=============================================================================================================================================================================
                vec3 aabbMin = meshletInfo.AABBMin.xyz;
                vec3 aabbMax = meshletInfo.AABBMax.xyz;

                vec2 aabbUV[8];
                float aabbDepth[8];
                vec3 corners[8] = vec3[](
                    vec3(aabbMin.x, aabbMin.y, aabbMin.z),   // - - -
                    vec3(aabbMax.x, aabbMax.y, aabbMax.z),   // + + +
                    vec3(aabbMax.x, aabbMin.y, aabbMin.z),   // + - -
                    vec3(aabbMin.x, aabbMax.y, aabbMin.z),   // - + -
                    vec3(aabbMin.x, aabbMin.y, aabbMax.z),   // - - +
                    vec3(aabbMin.x, aabbMax.y, aabbMax.z),   // - + +
                    vec3(aabbMax.x, aabbMin.y, aabbMax.z),   // + - +
                    vec3(aabbMax.x, aabbMax.y, aabbMin.z)    // + + -
                );

                for (uint i = 0; i < 8; i++)
                {
                    vec4 clip = cameraData.projection * cameraData.view * (objectInfo.model * vec4(corners[i], 1.0));
                    vec3 ndc = clip.xyz / clip.w;   // クリップ座標 -> NDC [-1~1]
                    vec2 uv = ndc.xy * 0.5 + 0.5;   // NDC座標 -> UV [0~1]
                    aabbUV[i] = uv;        
                    aabbDepth[i] = ndc.z;
                }

                vec2 minUV = aabbUV[0];
                vec2 maxUV = aabbUV[0];
                float minDepth = aabbDepth[0];
                for (uint i = 1; i < 8; i++)
                {
                    minUV.x = min(minUV.x, aabbUV[i].x);
                    minUV.y = min(minUV.y, aabbUV[i].y);
                    maxUV.x = max(maxUV.x, aabbUV[i].x);
                    maxUV.y = max(maxUV.y, aabbUV[i].y);
                    minDepth = min(minDepth, aabbDepth[i]);
                }
                minUV = clamp(minUV, vec2(0.0), vec2(1.0));
                maxUV = clamp(maxUV, vec2(0.0), vec2(1.0));

                float localMax = -1.0; 

                float bias = 0.0005;
                ivec2 mip0TextureSize = Sampler2DLoader_GetTextureSize(hiZSamplerID, 0);

                // AABB Size
                float aabbWidth = (maxUV.x - minUV.x) * float(mip0TextureSize.x);
                float aabbHeight = (maxUV.y - minUV.y) * float(mip0TextureSize.y);
                float maxDim = max(aabbWidth, aabbHeight);

                float mipLevel = 0.0;
                if (maxDim > 1.0)
                {
                    mipLevel = floor(log2(maxDim));
                }
                mipLevel = clamp(mipLevel, 0.0, hiZMipLevelMax);
                ivec2 targetMipTextureSize = Sampler2DLoader_GetTextureSize(hiZSamplerID, int(mipLevel));

                ivec2 minTexel = ivec2(minUV * targetMipTextureSize) - ivec2(1);    // bias: - ivec2(1) 本当にこれでいいのかなぁ…
                ivec2 maxTexel = ivec2(maxUV * targetMipTextureSize) + ivec2(1);    // bias: + ivec2(1) 本当にこれでいいのかなぁ…
                minTexel = clamp(minTexel, ivec2(0), targetMipTextureSize - ivec2(1));
                maxTexel = clamp(maxTexel, ivec2(0), targetMipTextureSize - ivec2(1));
                bool occCullingVisible = false;
                for (int x = minTexel.x; x <= maxTexel.x; x++)
                {
                    for (int y = minTexel.y; y <= maxTexel.y; y++)
                    {
                        float occluderDepth = Sampler2DLoader_TexelFetch(hiZSamplerID, ivec2(x, y), int(mipLevel)).r;
                        if ((occluderDepth + bias) >= minDepth)
                        {
                            uint appendIndex = atomicAdd(sRenderCount, 1);
                            payload.vbDispatchInfoIndex[appendIndex] = gl_GlobalInvocationID.x;
                            occCullingVisible = true;
                            break;
                        }
                    }
                    if (occCullingVisible) break;
                }
            }
        }
        else
        {
            // 強制描画
            uint appendIndex = atomicAdd(sRenderCount, 1);
            payload.vbDispatchInfoIndex[appendIndex] = gl_GlobalInvocationID.x;
        }
    }
    barrier();
    if (gl_LocalInvocationIndex == 0)
    {
        payload.renderCount = sRenderCount;
    }
    barrier();
    EmitMeshTasksEXT(sRenderCount, 1, 1);
}