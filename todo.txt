[OK] オブジェクト選択 (fence)
[OK] IDMapをComposition subpassのinput attachmentに追加
[OK] GameStage file読み込みの実用化
　・[OK] RenderSubsystemのオブジェクトクリア
　・[OK] F3でファイル保存機能の除去
　・[OK] 最後にObjectが持つDescriptorSetをfreeする
　・[OK] DescriptorPoolをShaderBaseに追加
[OK] StageObjectとComponentの移行
　・[OK] Object -> RenderComponentBase、そしてStageObjectを新しく作る？…
　　・[OK] これが一番早い気がする…
　　・[OK] StageObject
　　　・[OK] SerializeとDeserialize
　　　・[後回し] 複数Componentの合算結果を返す
　　　　・[後回し] AABB/OBB
　　　　・[後回し] TextureList? DiscriptorList?
　　　　・[後回し] その他…
[OK] UBO-> readonly SSBO
　・[OK] バッファの扱いがもっと自由になるように…
[OK] Bindless resources(texture/buffer)
[OK] ・PushConstant
　[OK] ・VS/PSに転送する部分を分別
[OK] ・ShaderObjectをpipeline下に配置
[OK] ・GLSL関数を増やす
　[OK] ・SSBOデータのロード関連
・[OK] FrustumCullingをTaskShaderに移植
　・[OK] まずはMesh単位
　　・[OK] 今はQuadなので、頂点数制限に収まる
・[OK] 頂点関連のDescripotrSetをRenderDescriptorに移行
・[OK] 全部の頂点データはrenderResourecesから取得できるようにする
　・[OK] PrimitiveGeometryは事前に定義する
　・[OK] String, std::vector<Mesh>
　　・[OK] RenderDescriptor
　　　・[OK] uint32_t AddModel(string, std::vector<Mesh>)
　　　　・[OK] runtime mapを持つ
　　　　・[OK] 同じMesh再利用できるようにstringで判定
・[OK] ここまで来たらCustomMeshを描画する
　・[OK] FBXLoadの修正
　　・[OK] 仮頂点データの追加 (Normalなど)
　・[OK] glTFLoadの追加
・[OK] 描画ができたら、Meshlet分割
・[OK] FBXのMeshlet対応
・[OK] Meshletの単体カリング

・[OK] TextureDescriptors
・[OK] 大掃除 - 最低限のものだけ残す

[OK] StageObject -> MObject
[OK] ・オブジェクトの登録機能
[OK] ・オブジェクトのデータ保管
[OK] ・オブジェクトのデータ(ObjectInfo)を渡す
[OK] Shaderの整理
[OK] Structsフォルダ
[OK] ・ObjectInfo.glsl
[OK] ・Transform.glsl
[OK] VBDispatchInfoの準備
[OK] ・ObjectID
[OK] ・Meshlet
[OK] ・VK_Loader.hの分割
[OK] ・MeshInfo/MeshletInfoの整理
[OK] ・meshoptimizerの導入
[OK] ・GLTFLoader
[OK] ・MFModel対応
[OK] ・Cullingチェックフラグの追加
[OK] ・VisibilityBufferの出力画像を用意
[OK] ・VisibilityBufferの出力
[OK] ・Skybox
[OK] ・LightingPassの追加
[OK] ・リアルタイム計算
[OK] ・TerrainPassの追加
[OK] ・HightMapの準備 (Forward)
[OK] ・HightMapの描画
[OK] ・Terrain描画の変更 (Forward -> VisibilityBuffer)
LightMapベイク

・WeekendHomework
　・Terrain
　　・HightMap 4096*4096
　　・チャンク分け
　　　・1Chunk: 64*64
　　・LOD
　　　・事前にAABBデータ作成
　　　・Runtime
　　　　・CPU側でFrustumCulling
　　　　・距離でLOD決め
　　　・GPU側
　　　　・GeomShaderで頂点作成、地形描画！！
　・Lighting
　　・リアルタイム計算
　　・Shadow
　　・LightMapベイク

描画する時は各Objectのm_vbDispatchInfoを取り出して、objectIDをセットして使う!!

StageObjectの親子関係
Visibility Buffer
Mesh Shader
2-phase occlusion culling

RayTracingメモ:
// BLAS作成
・createBottomLevelAccelerationStructure
　・[VkTransformMatrixKHR] Transform情報を作成
　　・現状は 位置固定 + 回転スケールなし でOK!
　・Transform Bufferの作成
　　・VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT　デバイスアドレス(GPUアドレス?)を利用
　　・VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR Accelerationデータだから必要?
　・VkAccelerationStructure (AS *BVHみたいもの?) の作成
　　・VkDeviceOrHostAddressConstKHR x3 (vertex,index,transform)
　　　・DeviceAddressの受け皿
　　・VkAccelerationStructureGeometryKHR (ASのジオメトリ情報)
　　　・三角形の構成
　　　・頂点情報
　　　・Index情報
　　　・etc.
　　・VkAccelerationStructureBuildRangeInfoKHR (ASのビルド範囲情報)
　　　・最初のvertex位置
　　　・Primitiveオフセット
　　　・Primitive数
　　　・Transformのオフセット
　　・ASデータ作成の準備はここまで
　・[必要に応じて] Bufferを作成 (必要に応じてShader内にGeom参照データを準備)
　・VkAccelerationStructureBuildGeometryInfoKHR (AS ジオメトリビルド情報)
　　・typeにAS種類 (TLAS/BLAS)
　　　・VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR (BLAS)
　　・flagsにビルドオプション
　　　・VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR
　　　　・ビルド時間よりもレイトレース速度を優先
　　・geomeryCount (ジオメトリ数) pGeometries (ジオメトリポインタ)
　・VkAccelerationStructureBuildSizesInfoKHR (ASビルドサイズ情報)
　　・PFN_vkGetAccelerationStructureBuildSizesKHR (VKの便利関数)
　　　・便利関数でビルドサイズを計算する
　・BLAS Bufferの作成
　　・VkBufferCreateInfo (いつものBufferCI)
　　　・usage
　　　　・VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR (AS用)
　　　　・VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT (DeviceAddress)
　　　・後はvmaに任せる
　・VkAccelerationStructureCreateInfoKHR (AS作成情報)
　　・buffer (AS Buffer)
　　　・BLAS Buffer をセット
	・size (ASサイズ)
	　・VkAccelerationStructureBuildSizesInfoKHR で計算したサイズ
	　　・VkAccelerationStructureBuildSizesInfoKHR::accelerationStructureSize
	・type (AS種類)
	　・VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR (BLAS)
　・vkCreateAccelerationStructureKHRでAS作成！！！！
　・Scratch Bufferの作成 (ASビルド用の一時Buffer)
　　・Bufferサイズは VkAccelerationStructureBuildSizesInfoKHR で計算した
　　　・VkAccelerationStructureBuildSizesInfoKHR::buildScratchSize
　　・VkBufferCreateInfo (いつものBufferCI)
　　　・usage
　　　　・VK_BUFFER_USAGE_STORAGE_BUFFER_BIT
　　　　・VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
　　　・後はvmaに任せる
　　・VkAccelerationStructureBuildGeometryInfoKHR　に情報追加
　　　・mode (VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR) ビルドモード
　　　・scratchData (Scratch BufferのDeviceAddress)
　　　・dstAccelerationStructure (BLAS ハンドル)
　・ASビルド！！！
　　・一時コマンドバッファの作成
　　・flushコマンドバッファ！
　・VkAccelerationStructureDeviceAddressInfoKHR (ASデバイスアドレス情報)
　　・BLASのDeviceAddressを取得
　・後片付け
　　・Scratch Bufferの削除

// TLAS作成
・createTopLevelAccelerationStructure
　・[VkTransformMatrixKHR] 上下反転
　・VkAccelerationStructureInstanceKHR (TLASインスタンス情報)
　　・transform
　　・instanceCustomIndex = 0
　　・mask = 0xFF
　　・instanceShaderBindingTableRecordOffset = 0
　　・flags = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR (裏面カリング無効)
　　・accelerationStructureReference (BLASのDeviceAddress)
　・Instace Bufferの作成
　　・VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT (DeviceAddress)
　　・VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR (ASデータ)
　・[VkDeviceOrHostAddressConstKHR] instanceのDeviceAddressを取得&セット
　・VkAccelerationStructureGeometryKHR (ASのジオメトリ情報)
　　・今度はvertex/indexではなく、instance情報をセット
　　・geometryType = VK_GEOMETRY_TYPE_INSTANCES_KHR (インスタンスジオメトリ)
　　・flags = VK_GEOMETRY_OPAQUE_BIT_KHR (不透明ジオメトリ)
　　・geometry.instances.arrayOfPointers = VK_FALSE (ポインタ配列ではない)
　　・geometry.instances.data = instanceのDeviceAddress (インスタンスデータ)
　・VkAccelerationStructureBuildGeometryInfoKHR (AS ジオメトリビルド情報)
　　・typeにAS種類 (TLAS/BLAS)
　　　・VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR (TLAS)
　　・flagsにビルドオプション
　　　・VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR
　　　　・ビルド時間よりもレイトレース速度を優先
　・TLAS Bufferの作成
　　・VkBufferCreateInfo (いつものBufferCI)
　　　・usage
　　　　・VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR (AS用)
　　　　・VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT (DeviceAddress)
　　　・後はvmaに任せる
　・VkAccelerationStructureCreateInfoKHR (AS作成情報)
　　・buffer (AS Buffer)
　　　・TLAS Buffer をセット
	・size (ASサイズ)
	　・VkAccelerationStructureBuildSizesInfoKHR で計算したサイズ
	　　・VkAccelerationStructureBuildSizesInfoKHR::accelerationStructureSize
	・type (AS種類)
	　・VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR (TLAS)
・vkCreateAccelerationStructureKHRでAS作成！！！！
・Scratch Bufferの作成 (ASビルド用の一時Buffer)
　・Bufferサイズは VkAccelerationStructureBuildSizesInfoKHR で計算した
　・VkBufferCreateInfo (いつものBufferCI)
　　・usage
　　　・VK_BUFFER_USAGE_STORAGE_BUFFER_BIT
　　　・VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
　　・後はvmaに任せる
　・VkAccelerationStructureBuildGeometryInfoKHR　に情報追加
　　・mode (VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR) ビルドモード
　　・scratchData (Scratch BufferのDeviceAddress)
　　・dstAccelerationStructure (TLAS ハンドル)
　　・geometryCount = 1; (インスタンスは1つだけ)
　　・pGeometries = VkAccelerationStructureGeometryKHR のポインタ
　・VkAccelerationStructureBuildRangeInfoKHR (ASのビルド範囲情報)
　　・primitiveCount = 1 (インスタンスは1つだけ)
　　・primiteiveOffset = 0
　　・firstVertex = 0
　　・transformOffset = 0
　・ASデータ作成の準備はここまで
　・ASビルド！！！
　　・一時コマンドバッファの作成
　　・flushコマンドバッファ！
　・VkAccelerationStructureDeviceAddressInfoKHR (ASデバイスアドレス情報)
　　・TLASのDeviceAddressを取得
　・後片付け
　　・Scratch Bufferの削除
　　・instance Bufferの削除

// レイトレースパイプライン作成
・createRayTracingPipeline
　・VkRayTracingShaderGroupCreateInfoKHR x3(raygen,raymiss,rayhit) (レイトレースシェーダグループ情報)
　　・raygen
　　　・type = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR (汎用シェーダ)
　　　・generalShader = 0 raygenシェーダのインデックス
　　・raymiss
　　　・type = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR (汎用シェーダ)
　　　・generalShader = 1 raymissシェーダのインデックス
　　・rayhit
　　　・type = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR (三角形ヒットグループ)
　　　・closestHitShader = 2 closesthitシェーダのインデックス
　　・必要に応じてanyHitShaderやintersectionShaderもセット可能
　・VkRayTracingPipelineCreateInfoKHR (レイトレースパイプライン作成情報)
　　・stageCount ShaderStageの数 pStages ShaderStageのポインタ
　　・groupCount シェーダグループ数 pGroups シェーダグループポインタ
　　・maxRecursionDepth = 1 (プライマリレイのみ、二次レイなし)
　・vkCreateRayTracingPipelinesKHRでpipeline作成！！！！

// SBT作成
・createShaderBindingTables
　・Deviceから必要なプロパティを取得 VkPhysicalDeviceRayTracingPipelinePropertiesKHR
　・const uint32_t handleSize (ハンドルサイズ)
　　・VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleSize
　・const uint32_t handleSizeAligned (ハンドルサイズ 32bit アライメント済み)
　　・VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleSize
　　・VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleAlignment
　・const uint32_t groupCount (シェーダグループ数)
　　・パイプライン作成時に指定したシェーダグループ数
　　・3 (raygen, raymiss, rayhit)
　・const uint32_t sbtSize (SBTサイズ)
　　・handleSizeAligned * groupCount
　・std::vector<uint8_t> shaderHandleStorage(stbSize); (シェーダハンドル格納用)
　・vkGetRayTracingShaderGroupHandlesKHR でシェーダハンドルを取得
　・各SBT Bufferの作成 x3 (raygen, raymiss, rayhit)
　　・Buffer作成
　　　・usage
　　　　・VK_BUFFER_USAVE_SHADER_BINDING_TABLE_BIT_KHR (SBT用)
　　　　・VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT (DeviceAddress)
　　　・size
　　　　・[VkPhysicalDeviceRayTracingPipelinePropertiesKHR] shaderGroupHandleSize * ハンドル数
　　・VkStrideedDeviceAddressRegionKHR (SBT情報構造体)
　　　・deviceAddress (SBT BufferのDeviceAddress)
　　　・stride = handleSizeAligned (ハンドルサイズ 32bit アライメント済み)
　　　・size = handleSizeAligned * ハンドル数
　　・mapしてSBTデータを書き込む
　・ハンドルコピー (shaderHandleStorage)
　　・memcpy(RayTracingShaderGroupHandles, handleSize) * 3

// ディスクリプタセット作成
・createDescriptorSets
　・普通のVkWriteDescriptorSetではAS情報はセットできない
　　・VkWriteDescriptorSetAccelerationStructureKHR を使う
　・VkWriteDescriptorSetAccelerationStructureKHR (AS情報構造体)
　　・accelerationStructureCount = 1 (LASは1つだけ)
　　・pAccelerationStructures = TLASのハンドルポインタ
　・VkWriteDescriptorSet (ディスクリプタセット書き込み情報)
　　・pNext に VkWriteDescriptorSetAccelerationStructureKHR のポインタをセット

// その他
・Shaderの内部はBLASを作成する際にセットしたGeometry情報をgl_GeometryIndexEXTで取得可能が、データ構造をどうするかは要検討

createTopLevelAccelerationStructure
createRayTracingPipeline
createShaderBindingTables
createDescriptorSets

// todo. ビルド手順
// Scratch buffer sizeのmaxを取り出す (forとstd::maxでOK)
// 最大値でScratchBuffer作成
// BuildGeomInfo作成
// BuildRangeInfo*作成 (1つでOK)
// CmdBuildAS！
